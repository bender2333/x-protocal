/*!
    \file    ibl_pkcau.c
    \brief   IBL PKCAU configure for GD32 SDK

    \version 2024-06-30, V1.0.0, demo for GD32
*/

/*
    Copyright (c) 2024, GigaDevice Semiconductor Inc.

    Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

    1. Redistributions of source code must retain the above copyright notice, this
       list of conditions and the following disclaimer.
    2. Redistributions in binary form must reproduce the above copyright notice,
       this list of conditions and the following disclaimer in the documentation
       and/or other materials provided with the distribution.
    3. Neither the name of the copyright holder nor the names of its contributors
       may be used to endorse or promote products derived from this software without
       specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
OF SUCH DAMAGE.
*/

#include "ibl_includes.h"

void rom_pka_config(void)
{
    ibl_printf("%s : %d\r\n", __FILE__, __LINE__);
#if defined(PLATFORM_GD32F5XX)
    rcu_periph_clock_enable(RCU_PKCAU);
    /* wait for PKCAU busy flag to reset */
    while(RESET != pkcau_flag_get(PKCAU_FLAG_BUSY));
#endif
}

#if defined(PLATFORM_GD32F5XX)

/* Arithmetic Multiplication */
/* res: A x B */
int rom_pka_amul(IN const uint32_t* a, uint32_t a_size,
                        IN const uint32_t* b, uint32_t b_size,
                        OUT uint32_t* res)
{
    int ret = 0;
    pkcau_arithmetic_parameter_struct arithmetic_para;

    pkcau_arithmetic_struct_para_init(&arithmetic_para);
    arithmetic_para.oprd_a = (uint8_t *)a;
    arithmetic_para.oprd_a_len = a_size;
    arithmetic_para.oprd_b = (uint8_t *)b;
    arithmetic_para.oprd_b_len = b_size;

    ibl_get_mutex(MUTEX_TYPE_PKCAU);
    pkcau_arithmetic_operation(&arithmetic_para, PKCAU_MODE_ARITHMETIC_MUL, (uint8_t *)res);
    ibl_put_mutex(MUTEX_TYPE_PKCAU);

    return ret;
}

/* modulus exponent */
/* res: (A exp e) mod n */
int rom_pka_modexp(IN const uint32_t* a,
                IN const uint32_t* e, int e_size,
                IN const uint32_t* n, int n_size,
                OUT uint32_t* res)
{
    int ret = 0;

    ibl_get_mutex(MUTEX_TYPE_PKCAU);
    ibl_put_mutex(MUTEX_TYPE_PKCAU);

    return ret;
}

/* ECDSA sign */
int rom_pka_ecdsa_sign(IN uint8_t* d,
                               IN uint8_t* k,
                               IN uint8_t* hash,
                               IN void *group,
                               OUT uint8_t* r,
                               OUT uint8_t* s)
{
    int ret = 0;

    return ret;
}

/* ECDSA Verify */
int ibl_pka_ecdsa_verify(IN uint8_t *r,
                                     IN uint8_t *s,
                                     IN uint8_t *hash,
                                     IN uint8_t *pk_x,
                                     IN uint8_t *pk_y,
                                     IN void *group)
{
    int ret = 0;

    return ret;
}

/* return 0: (x, y) on curve */
uint32_t rom_pka_ecp_check(IN void *group,
                                 IN uint8_t *x,
                                 IN uint8_t *y)
{
    uint32_t ret = 0;

    return ret;
}


/* ECC Fp scalar multiply */
/* x_res: k x P coordinate x */
/* y_res: k x P coordinate y */
int rom_pka_ecp_mul(IN void *group,
                         IN uint8_t *px,
                         IN uint8_t *py,
                         IN uint8_t *k,
                         IN uint32_t k_size,
                         OUT uint8_t *rx,
                         OUT uint8_t *ry)
{
    int ret = 0;

    return ret;
}
#endif  /* PLATFORM_GDM32 */

#ifdef ROM_SELF_TEST
#if defined(PLATFORM_GD32F5XX)
/* modular expoentation */
#define ME_A_SIZE       128
#define ME_B_SIZE       128
#define ME_mod_SIZE     128
#define ME_res_SIZE     128
static const uint8_t ME_A[ME_A_SIZE] = {
    0x15, 0x5d, 0x99, 0xd2, 0xc1, 0xdd, 0xf5, 0x90, 0xcc, 0x13, 0x2d, 0x45, 0xc0, 0xa0, 0x5a, 0x27, 0x60, 0xe6, 0x93, 0x5a, 0x63, 0x81, 0x61, 0x73, 0xc5, 0xcf, 0xe5, 0xcd, 0x49, 0xb0, 0x46, 0x99,
    0x2e, 0xce, 0x75, 0x0e, 0x87, 0x12, 0xce, 0xe1, 0xbf, 0x54, 0x6c, 0x89, 0xa1, 0x78, 0xc6, 0x2f, 0xca, 0x80, 0x81, 0x39, 0x1e, 0x63, 0x19, 0xb8, 0x58, 0xcb, 0xf5, 0x62, 0x7a, 0xd2, 0xec, 0x74,
    0x58, 0x21, 0xd2, 0x22, 0xdd, 0x61, 0xfc, 0xdb, 0x2f, 0x91, 0xb9, 0x71, 0xe0, 0x5e, 0x17, 0xe7, 0x59, 0x11, 0xb2, 0xea, 0x30, 0x73, 0xe9, 0xee, 0xeb, 0xe3, 0xd0, 0xe0, 0xaa, 0x3c, 0x23, 0x68,
    0x65, 0x62, 0xe7, 0xc9, 0x52, 0xcf, 0x0e, 0xdc, 0xb0, 0x8b, 0xa0, 0xb6, 0x20, 0xa5, 0x3a, 0x09, 0xd7, 0x4a, 0x08, 0x34, 0x06, 0xba, 0x0a, 0x06, 0x5b, 0xb5, 0x09, 0xd4, 0x69, 0x2c, 0x26, 0xfb};
static const uint8_t ME_B[ME_B_SIZE] = {
    0xb1, 0x38, 0x83, 0xf9, 0x66, 0xa6, 0x0f, 0x8f, 0x6d, 0xa5, 0x5f, 0x72, 0x9d, 0xd2, 0x9b, 0xb9, 0x88, 0x19, 0x59, 0x6a, 0xc3, 0xd4, 0xdb, 0x32, 0xee, 0xc4, 0x40, 0x19, 0x5f, 0x7a, 0xc8, 0x39,
    0x3b, 0x81, 0x15, 0xe4, 0x6f, 0xaa, 0x3f, 0x70, 0x25, 0xf7, 0x68, 0x4c, 0x28, 0x02, 0xd1, 0x00, 0xf7, 0xba, 0xb5, 0xde, 0x12, 0x6c, 0xee, 0xe3, 0x8b, 0x6f, 0xb7, 0x71, 0x93, 0x43, 0xd5, 0xd2,
    0x93, 0x31, 0x98, 0x15, 0x72, 0xde, 0x99, 0xf9, 0x89, 0x59, 0x55, 0xd8, 0xf2, 0xbb, 0xa7, 0x6d, 0x5a, 0xad, 0xee, 0x68, 0x7e, 0x9a, 0x81, 0xdb, 0x49, 0x97, 0x87, 0x2a, 0x98, 0x05, 0xe5, 0xbe,
    0xd4, 0x99, 0xe2, 0xf2, 0x74, 0xf3, 0x85, 0xfb, 0xe6, 0x6d, 0xec, 0x5a, 0xee, 0x57, 0xc4, 0x7c, 0x7f, 0x2c, 0x49, 0x6d, 0xcb, 0x8b, 0x03, 0xc4, 0x95, 0x35, 0x1d, 0xbc, 0xef, 0x42, 0xd5, 0xe0};
static const uint8_t ME_mod[ME_mod_SIZE] = {
    0x39, 0xfd, 0xd2, 0x70, 0x55, 0xc0, 0x5e, 0xe3, 0xbe, 0xe2, 0x21, 0x26, 0x2f, 0x2b, 0x38, 0x5e, 0x9e, 0xfa, 0x06, 0x32, 0xfe, 0x6c, 0xdf, 0x4b, 0xca, 0x55, 0x23, 0x33, 0x61, 0x75, 0x21, 0x1f,
    0x09, 0xff, 0x15, 0x51, 0xf5, 0xaf, 0x38, 0x58, 0x4c, 0xdc, 0x2e, 0xfa, 0x5f, 0x24, 0x7d, 0x5c, 0x97, 0xeb, 0xc6, 0x48, 0x73, 0x2e, 0x25, 0x75, 0x9d, 0xc3, 0x61, 0xca, 0xae, 0xf4, 0xf8, 0xa8,
    0x6e, 0x0e, 0x18, 0xef, 0x4d, 0x13, 0x2a, 0x9a, 0x3c, 0xb0, 0x83, 0xd1, 0xd3, 0x01, 0xe4, 0xa0, 0x88, 0x26, 0x6f, 0x66, 0x2c, 0xfc, 0xb2, 0x35, 0xe9, 0xbb, 0x0a, 0xf1, 0xba, 0x22, 0x39, 0x5a,
    0xd6, 0xc8, 0xcc, 0x54, 0x96, 0x29, 0xf7, 0xb8, 0xf1, 0x81, 0xa3, 0x88, 0x11, 0xdc, 0x2a, 0x96, 0xf0, 0xbe, 0x90, 0xf4, 0x7d, 0xea, 0xa6, 0xb5, 0x72, 0x22, 0xd4, 0x53, 0xb3, 0x26, 0xff, 0xfe};
static const uint8_t ME_res[ME_res_SIZE] = {
    0x8b, 0x3e, 0xe4, 0x60, 0xaa, 0xa3, 0xa6, 0xdc, 0x6f, 0xa1, 0xf9, 0x4d, 0x46, 0x83, 0x37, 0x0f, 0x5d, 0x4f, 0xf8, 0xdd, 0xb0, 0xfc, 0x3d, 0xc0, 0x4e, 0xba, 0x08, 0x34, 0x91, 0xf7, 0x5e, 0x0d,
    0x99, 0xfd, 0x7c, 0x76, 0xdb, 0xba, 0xe1, 0xc4, 0x66, 0x11, 0x57, 0x1f, 0xea, 0xa6, 0x77, 0x75, 0xa3, 0x3a, 0xe1, 0x69, 0x11, 0xaf, 0x6c, 0x4d, 0x46, 0xec, 0x9c, 0x45, 0xef, 0x39, 0xe9, 0xdc,
    0xfb, 0xea, 0xf8, 0x2f, 0xa5, 0x79, 0x71, 0xf1, 0xd9, 0x9f, 0xbf, 0x64, 0x16, 0x7a, 0xcd, 0xd4, 0xc2, 0x99, 0x1e, 0xc3, 0x45, 0x16, 0x52, 0x29, 0x29, 0x53, 0xe2, 0x50, 0xc0, 0x52, 0x3c, 0x0d,
    0x19, 0xfd, 0xea, 0x64, 0x15, 0xb6, 0x33, 0x8b, 0x69, 0x4f, 0x07, 0x4f, 0x63, 0x84, 0xa8, 0x0b, 0xfa, 0xa6, 0x8a, 0x4d, 0x26, 0x18, 0x49, 0xc0, 0x4b, 0x29, 0x01, 0x95, 0x8e, 0xcf, 0x68, 0xc2};

/* ECP scalar multiple */
#define EC_PMUL_x_SIZE 32
#define EC_PMUL_y_SIZE 32
#define EC_PMUL_k_SIZE  32
#define EC_PMUL_res_x_SIZE      32
#define EC_PMUL_res_y_SIZE      32
static const uint8_t EC_PMUL_x[EC_PMUL_x_SIZE] = {0x62, 0x32, 0xce, 0x9a, 0xbd, 0x53, 0x44, 0x3a, 0xc2, 0x23, 0xbd, 0xe3, 0xe1, 0x27, 0xde, 0xb9, 0xaf, 0xb7, 0x81, 0xfc, 0x2f, 0x48, 0x4b, 0x2c, 0xcb, 0x57, 0x7e, 0xcb, 0xb9, 0xae, 0xd2, 0x8b};
static const uint8_t EC_PMUL_y[EC_PMUL_y_SIZE]  = {0x97, 0x69, 0x04, 0x2f, 0xc7, 0x54, 0x1d, 0x5c, 0x54, 0x8e, 0xed, 0x2d, 0x13, 0x45, 0x77, 0xc2, 0xc9, 0x1d, 0x61, 0x14, 0x1a, 0x46, 0xf8, 0x97, 0xfd, 0xc4, 0xda, 0xc3, 0x35, 0xf8, 0x7e, 0x54};
static const uint8_t EC_PMUL_k[EC_PMUL_k_SIZE] = {0x93, 0x2b, 0x2f, 0x46, 0xb6, 0xab, 0xf7, 0x85, 0x24, 0x94, 0x4d, 0x03, 0x45, 0x03, 0x57, 0xb0, 0x42, 0x73, 0x02, 0x9f, 0xe0, 0xa1, 0xe2, 0xbf, 0xcd, 0xe9, 0x8c, 0x1b, 0xb8, 0xfd, 0x68, 0xd1};
static const uint8_t EC_PMUL_res_x[EC_PMUL_res_x_SIZE] = {0x46, 0x05, 0x56, 0xba, 0x29, 0x79, 0x12, 0xaf, 0xa2, 0x52, 0x6f, 0xd2, 0x77, 0x8b, 0xd8, 0x94, 0x99, 0xc8, 0x08, 0xb6, 0xbb, 0xee, 0x20, 0x83, 0x76, 0xe4, 0x87, 0xc1, 0x1a, 0x2b, 0x67, 0x68};
static const uint8_t EC_PMUL_res_y[EC_PMUL_res_y_SIZE] = {0x0b, 0x89, 0x12, 0xb8, 0x79, 0x53, 0x0a, 0x47, 0xf9, 0x44, 0x7b, 0x7f, 0xa2, 0x5d, 0xa9, 0x1c, 0xa7, 0xaf, 0x1a, 0x6d, 0x65, 0x67, 0x89, 0xa9, 0x17, 0x45, 0xcb, 0x14, 0x3c, 0x69, 0x5b, 0x10};

/* ECDSA */
static const uint32_t ecc_sign_d[] = { 0x76d457ed, 0x462df78c, 0x7cfde9f9, 0xe33724c6, 0xe2f784c5, 0xd513d2aa };
static const uint32_t ecc_sign_k[] = { 0x12153524, 0xc0895e81, 0x8484d609, 0xb1f05663, 0x06b97b0d, 0x46df998d };
static const uint32_t ecc_verify_r[] = { 0x0c46542d, 0xb9239af5, 0xc99ff703, 0xa641923d, 0xc983b7b3, 0xe30de3e1 };
static const uint32_t ecc_verify_s[] = { 0x93659000, 0xa811f4bc, 0x46b8fc04, 0x7297c6fd, 0xd298147c, 0x467ebcad };
static const uint32_t ecc_verify_x[] = { 0x8ed6aaef, 0x7ade7873, 0x53c2211a, 0xe0d255af, 0x2fe76d72, 0xd5622721 };
static const uint32_t ecc_verify_y[] = { 0xdbbf43bf, 0xd0a74ceb, 0xd79eadfd, 0x0c00bea8, 0xde5dcdb6, 0xfe28ddfa };
static const uint32_t ecc_verify_hash[] = { 0xb2c28465, 0x89375212, 0x00f3e301, 0x06d7cd0d, 0x3b23f176, 0x1e8dcd3d };

#define BYTES_TO_T_UINT_4( a, b, c, d )             \
    ( (uint32_t) a <<  0 ) |                          \
    ( (uint32_t) b <<  8 ) |                          \
    ( (uint32_t) c << 16 ) |                          \
    ( (uint32_t) d << 24 )

#define BYTES_TO_T_UINT_8( a, b, c, d, e, f, g, h ) \
    BYTES_TO_T_UINT_4( a, b, c, d ),                \
    BYTES_TO_T_UINT_4( e, f, g, h )

static const uint32_t brainpoolP256r1_p[] = {
    BYTES_TO_T_UINT_8( 0x77, 0x53, 0x6E, 0x1F, 0x1D, 0x48, 0x13, 0x20 ),
    BYTES_TO_T_UINT_8( 0x28, 0x20, 0x26, 0xD5, 0x23, 0xF6, 0x3B, 0x6E ),
    BYTES_TO_T_UINT_8( 0x72, 0x8D, 0x83, 0x9D, 0x90, 0x0A, 0x66, 0x3E ),
    BYTES_TO_T_UINT_8( 0xBC, 0xA9, 0xEE, 0xA1, 0xDB, 0x57, 0xFB, 0xA9 ),
};
static const uint32_t brainpoolP256r1_a[] = {
    BYTES_TO_T_UINT_8( 0xD9, 0xB5, 0x30, 0xF3, 0x44, 0x4B, 0x4A, 0xE9 ),
    BYTES_TO_T_UINT_8( 0x6C, 0x5C, 0xDC, 0x26, 0xC1, 0x55, 0x80, 0xFB ),
    BYTES_TO_T_UINT_8( 0xE7, 0xFF, 0x7A, 0x41, 0x30, 0x75, 0xF6, 0xEE ),
    BYTES_TO_T_UINT_8( 0x57, 0x30, 0x2C, 0xFC, 0x75, 0x09, 0x5A, 0x7D ),
};
static const uint32_t brainpoolP256r1_b[] = {
    BYTES_TO_T_UINT_8( 0xB6, 0x07, 0x8C, 0xFF, 0x18, 0xDC, 0xCC, 0x6B ),
    BYTES_TO_T_UINT_8( 0xCE, 0xE1, 0xF7, 0x5C, 0x29, 0x16, 0x84, 0x95 ),
    BYTES_TO_T_UINT_8( 0xBF, 0x7C, 0xD7, 0xBB, 0xD9, 0xB5, 0x30, 0xF3 ),
    BYTES_TO_T_UINT_8( 0x44, 0x4B, 0x4A, 0xE9, 0x6C, 0x5C, 0xDC, 0x26 ),
};
static const uint32_t brainpoolP256r1_gx[] = {
    BYTES_TO_T_UINT_8( 0x62, 0x32, 0xCE, 0x9A, 0xBD, 0x53, 0x44, 0x3A ),
    BYTES_TO_T_UINT_8( 0xC2, 0x23, 0xBD, 0xE3, 0xE1, 0x27, 0xDE, 0xB9 ),
    BYTES_TO_T_UINT_8( 0xAF, 0xB7, 0x81, 0xFC, 0x2F, 0x48, 0x4B, 0x2C ),
    BYTES_TO_T_UINT_8( 0xCB, 0x57, 0x7E, 0xCB, 0xB9, 0xAE, 0xD2, 0x8B ),
};
static const uint32_t brainpoolP256r1_gy[] = {
    BYTES_TO_T_UINT_8( 0x97, 0x69, 0x04, 0x2F, 0xC7, 0x54, 0x1D, 0x5C ),
    BYTES_TO_T_UINT_8( 0x54, 0x8E, 0xED, 0x2D, 0x13, 0x45, 0x77, 0xC2 ),
    BYTES_TO_T_UINT_8( 0xC9, 0x1D, 0x61, 0x14, 0x1A, 0x46, 0xF8, 0x97 ),
    BYTES_TO_T_UINT_8( 0xFD, 0xC4, 0xDA, 0xC3, 0x35, 0xF8, 0x7E, 0x54 ),
};
static const uint32_t brainpoolP256r1_n[] = {
    BYTES_TO_T_UINT_8( 0xA7, 0x56, 0x48, 0x97, 0x82, 0x0E, 0x1E, 0x90 ),
    BYTES_TO_T_UINT_8( 0xF7, 0xA6, 0x61, 0xB5, 0xA3, 0x7A, 0x39, 0x8C ),
    BYTES_TO_T_UINT_8( 0x71, 0x8D, 0x83, 0x9D, 0x90, 0x0A, 0x66, 0x3E ),
    BYTES_TO_T_UINT_8( 0xBC, 0xA9, 0xEE, 0xA1, 0xDB, 0x57, 0xFB, 0xA9 ),
};

static const uint32_t ecdsa_p[] = { 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
static const uint32_t ecdsa_n[] = { 0xB4D22831, 0x146BC9B1, 0x99DEF836, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
static const uint32_t ecdsa_a[] = { 0xFFFFFFFc, 0xFFFFFFFF, 0xFFFFFFFE, 0xFFFFFFFF, 0xFFFFFFFF, 0xFFFFFFFF };
static const uint32_t ecdsa_gx[] = { 0x82FF1012, 0xF4FF0AFD, 0x43A18800, 0x7CBF20EB, 0xB03090F6, 0x188DA80E };
static const uint32_t ecdsa_gy[] = { 0x1E794811, 0x73F977A1, 0x6B24CDD5, 0x631011ED, 0xFFC8DA78, 0x07192B95 };

static pka_ecgrp_t sb_curve_group1;
static pka_ecgrp_t sb_curve_group2;

#if 1
/* RSA CRT */
static const uint32_t rsa_crt_dp[] = {
    0x5585e2e5, 0x0e45065e, 0x56e703de, 0xa66a95bf,
    0x8f068b5c, 0x6631aca4, 0xd7462114, 0x90cd3642,
    0x05553fc9, 0x13be67e2, 0x09463166, 0x41c5eceb,
    0x82df8f99, 0x3cacb7b3, 0xcb8bd1ca, 0xc9d34be2,
};
static const uint32_t rsa_crt_dq[] = {
    0x31ca6341, 0xe51c8b52, 0x0e416b59, 0xb4861693,
    0x1968fff1, 0xaecc2a82, 0x561c3c89, 0xff467d2f,
    0xf51e78df, 0x5f641f73, 0x220b7b9b, 0xc2f4b664,
    0x712245af, 0xb9d012d1, 0xf137f918, 0xb4793a0b,
};
static const uint32_t rsa_crt_qinv[] = {
    0xe87ab878, 0xafce17ec, 0xc62dd97a, 0x13ac241d,
    0x07cc9d1d, 0x3dbd059d, 0x99f8335a, 0x5604e3c7,
    0x004a4395, 0xa1acbc0d, 0x2932b5c5, 0x56c002a2,
    0x0f3924d0, 0x7f1caf96, 0xb00e9353, 0xdfaab384,
};
static const uint32_t rsa_crt_p[] = {
    0xde49617d, 0x96bf391c, 0xbc6502ee, 0x510d861a,
    0xdc13957b, 0xcfa0aae1, 0x56b292b0, 0x8459d34b,
    0x49884b0d, 0x98e7f9a2, 0x98f86535, 0xfcc95087,
    0x84823d6d, 0xd87ba775, 0x790197eb, 0xe0bd40c5,
};
static const uint32_t rsa_crt_q[] = {
    0x70dab131, 0xa9694f6b, 0xfa3311e5, 0x92a10260,
    0x4cf125d5, 0x9070a57d, 0x9eb0ba21, 0x22dc96ae,
    0xa6a69415, 0x32d500c1, 0x51fda22b, 0x12b187bb,
    0xcf58483e, 0xd4da71b3, 0x460d83af, 0xcb196fdf,
};
static const uint32_t rsa_crt_A[] = {
    0x9c1fe985, 0x30280ce7, 0x3e14359f, 0x42baf9b9,
    0x2f4ad51a, 0x219e4963, 0xcb3b3994, 0x4f60b8a9,
    0xb6667e6c, 0xd9c1ca8b, 0xb3f0465c, 0xcc7909a4,
    0x87273711, 0x127f2de3, 0x45161380, 0x76f6e1aa,
    0xe08ce8ea, 0xcbaf752e, 0x162f3200, 0x5a8a054b,
    0x66086c13, 0x1d5fb1ee, 0x34e35c69, 0x8504d525,
    0x513f15dc, 0x9943d7e9, 0x4b23a842, 0x73dd469a,
    0x5ee92c1b, 0xa2fdceca, 0x54e1236b, 0xb4bd2a41,
};
static const uint32_t rsa_crt_res[] = {
    0xA8C0C944, 0xE7A0DDF2, 0x2C6F68E7, 0x2FCE692E,
    0xEC3B95C4, 0xC9DAF03B, 0x5B3E9B56, 0x128365AB,
    0x44306EA7, 0x8A873374, 0x35564CD9, 0x8B3F4EBD,
    0x99F1B3B6, 0x1E5A4DE5, 0xB556228C, 0xE35AD90C,
    0xCADD0888, 0x857B9F8D, 0xE3B18563, 0xE963CC77,
    0x56967595, 0x3DEA61AA, 0x8AFBB0DF, 0xCAB428EE,
    0x75D4D69D, 0x042D8210, 0x788C2A86, 0xDD9BF51E,
    0x18340D43, 0xB5313751, 0x1CDE1125, 0x22B7BC7F
};
#endif
#endif /* PLATFORM_GDM32 */

void pka_self_test(void)
{
#if defined(PLATFORM_GD32F5XX)
    uint8_t *res_x = NULL, *res_y = NULL, *res = NULL;
    int err;

    rom_pka_config();

    sb_curve_group1.p = (uint8_t *)brainpoolP256r1_p;
    sb_curve_group1.a = (uint8_t *)brainpoolP256r1_a;
    sb_curve_group1.b = (uint8_t *)brainpoolP256r1_b;
    sb_curve_group1.gx = (uint8_t *)brainpoolP256r1_gx;
    sb_curve_group1.gy = (uint8_t *)brainpoolP256r1_gy;
    sb_curve_group1.n = (uint8_t *)brainpoolP256r1_n;
    sb_curve_group1.p_length = sizeof(brainpoolP256r1_p);
    sb_curve_group1.n_length = sizeof(brainpoolP256r1_n);
    sb_curve_group1.a_sign = POSITIVE;

    sb_curve_group2.p = (uint8_t *)ecdsa_p;
    sb_curve_group2.a = (uint8_t *)ecdsa_a;
    sb_curve_group2.b = (uint8_t *)ecdsa_a;
    sb_curve_group2.gx = (uint8_t *)ecdsa_gx;
    sb_curve_group2.gy = (uint8_t *)ecdsa_gy;
    sb_curve_group2.n = (uint8_t *)ecdsa_n;
    sb_curve_group2.p_length = sizeof(ecdsa_p);
    sb_curve_group2.n_length = sizeof(ecdsa_p);
    sb_curve_group2.a_sign = POSITIVE;

    ibl_printf("========== ModExp for RSA ===========\r\n");
    /* modular exponential normal mode and fast mode*/
    res = (uint8_t *)ibl_malloc(sizeof(char) * ME_res_SIZE);
    rom_pka_modexp((uint32_t *)ME_A,
              (uint32_t *)ME_B,
              ME_B_SIZE,
              (uint32_t *)ME_mod,
              ME_mod_SIZE,
              (uint32_t *)res);
    if (memcmp(ME_res, res, ME_res_SIZE)) {
        ibl_printf("ModExp error (%d)\r\n", err);
        ibl_print_data(IBL_ALWAYS, "ME_res:", (uint8_t *)ME_res, ME_res_SIZE);
        ibl_print_data(IBL_ALWAYS, "res:", res, ME_res_SIZE);
        goto exit;
    } else {
        ibl_printf("ModExp test pass\r\n");
    }
    ibl_free(res); res = NULL;

#if 0  /* Since we use the reversed arrays as input parameters for Mbedtls, the following two examples will be failed. */
    ibl_printf("========== ECC point multiply ===========\r\n");
    /* ecc point multiply */
    res_x = ibl_malloc(EC_PMUL_res_x_SIZE);
    ibl_memset(res_x, 0, EC_PMUL_res_x_SIZE);
    res_y = ibl_malloc(EC_PMUL_res_y_SIZE);
    ibl_memset(res_y, 0, EC_PMUL_res_y_SIZE);
    rom_pka_ecp_mul(&sb_curve_group1,
                        (uint8_t *)EC_PMUL_x,
                        (uint8_t *)EC_PMUL_y,
                        (uint8_t *)EC_PMUL_k,
                        EC_PMUL_k_SIZE,
                        (uint8_t *)res_x,
                        (uint8_t *)res_y);
    if (memcmp(res_x, EC_PMUL_res_x, EC_PMUL_res_x_SIZE) || memcmp(res_y, EC_PMUL_res_y, EC_PMUL_y_SIZE)) {
        ibl_printf("ECC point multiply error\r\n");
        ibl_print_data(IBL_ALWAYS, "EC_PMUL_res_x:", (uint8_t *)EC_PMUL_res_x, EC_PMUL_res_x_SIZE);
        ibl_print_data(IBL_ALWAYS, "res_x:", res_x, EC_PMUL_res_x_SIZE);
        ibl_print_data(IBL_ALWAYS, "EC_PMUL_res_y:", (uint8_t *)EC_PMUL_res_y, EC_PMUL_y_SIZE);
        ibl_print_data(IBL_ALWAYS, "res_y:", res_y, EC_PMUL_y_SIZE);
        goto exit;
    } else {
        ibl_printf("ECC point multiply test pass\r\n");
    }

    ibl_printf("========== ECDSA verify ===========\r\n");
    err = ibl_pka_ecdsa_verify((uint8_t*)ecc_verify_r,
                                    (uint8_t*)ecc_verify_s,
                                    (uint8_t*)ecc_verify_hash,
                                    (uint8_t*)ecc_verify_x,
                                    (uint8_t*)ecc_verify_y,
                                    &sb_curve_group2);
    if (err != ERR_OK) {
        ibl_printf("ECDSA verify error (%d)\r\n", err);
        goto exit;
    } else {
        ibl_printf("ECDSA verify test pass\r\n");
    }
#endif
#if 0
    ibl_printf("========== RSA CRT ===========\r\n");
    res = ibl_malloc(128);
    ibl_memset(res, 0, 128);
    ibl_pka_rsa_crt((uint32_t *)rsa_crt_dp,
                            (uint32_t *)rsa_crt_dq,
                            (uint32_t *)rsa_crt_qinv,
                            (uint32_t *)rsa_crt_p,
                            (uint32_t *)rsa_crt_q,
                            128,
                            (uint32_t *)rsa_crt_A,
                            128,
                            res);
    if (memcmp(rsa_crt_res, res, 128)) {
        ibl_printf("RSA CRT error (%d)\r\n", err);
    } else {
        ibl_printf("RSA CRT test pass\r\n");
    }
    ibl_free(res); res = NULL;
#endif
exit:
    if (res)
        ibl_free(res);
    if (res_x)
        ibl_free(res_x);
    if (res_y)
        ibl_free(res_y);
#endif  /* PLATFORM_GDM32 */
}
#endif  /* ROM_SELF_TEST */

